pekko {
    loglevel = "INFO"
    stdout-loglevel = "INFO"
    loggers = ["org.apache.pekko.event.slf4j.Slf4jLogger"]
    logging-filter = "org.apache.pekko.event.slf4j.Slf4jLoggingFilter"
    log-dead-letters-during-shutdown = off
    log-dead-letters = off
    
    actor {
        provider = cluster

        debug {
            receive = off
            lifecycle = off
            unhandled = off
            autoreceive = off
        }
        allow-java-serialization = off
        serializers {
            proto = "org.apache.pekko.remote.serialization.ProtobufSerializer"
            envelope = "org.interscity.htc.core.serializer.EntityEnvelopeSerializer"
            actor-interaction = "org.interscity.htc.core.serializer.ActorInteractionSerializer"
            jackson-json = "org.apache.pekko.serialization.jackson.JacksonJsonSerializer"
            jackson-cbor = "org.apache.pekko.serialization.jackson.JacksonCborSerializer"
        }
        serialization-bindings {
            "org.interscity.htc.core.entity.event.EntityEnvelopeEvent" = envelope
            "scalapb.GeneratedMessage" = proto
            "org.interscity.htc.core.entity.event.ActorInteractionEvent" = actor-interaction
            "org.interscity.htc.core.entity.event.control.execution.TimeManagerRegisterEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.execution.LocalTimeWindowReport" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.execution.UpdateGlobalTimeWindow" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.CreateActorsEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.FinishCreationEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.FinishLoadDataEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.LoadDataCreatorRegisterEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.InitializeEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.LoadDataEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.data.BaseEventData" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.report.RegisterReportersEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.report.ReportEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.LoadDataSourceEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.LoadNextEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.ProcessBatchesEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.ProcessNextCreateChunk" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.SendBatchToCreators" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.ProcessNextFileChunk" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.CloseAndFinish" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.StartLoadingFile" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.ProcessNextChunk" = jackson-cbor
            "org.interscity.htc.core.entity.event.control.load.RetryPendingAcks" = jackson-cbor
            "org.interscity.htc.core.entity.event.SpontaneousEvent" = jackson-cbor
            "org.interscity.htc.core.entity.event.FinishEvent" = jackson-cbor
            "org.interscity.htc.core.actor.ActorSerializable" = jackson-cbor
            "org.interscity.htc.core.entity.actor.properties.Properties" = jackson-cbor
            "org.interscity.htc.core.entity.actor.properties.CreatorProperties" = jackson-cbor
            "org.interscity.htc.core.entity.state.BaseState" = jackson-cbor
            "java.time.LocalDateTime" = jackson-cbor
        }
    }

    persistence {
          journal {
            plugin = "pekko.persistence.journal.inmem"
            inmem {
                class = "org.apache.pekko.persistence.journal.inmem.InmemJournal"
            }
          }
          snapshot-store {
            plugin = "pekko.persistence.snapshot-store.local"
            local {
              class = "org.apache.pekko.persistence.snapshot.local.LocalSnapshotStore"
              dir = "/app/hyperbolic-time-chamber/snapshots"
            }
          }
    }

    remote {
        artery {
            canonical {
                hostname = ${clustering.ip}
                port = ${clustering.port}
            }
        }
    }

    cluster {
        downing-provider-class = "org.apache.pekko.cluster.sbr.SplitBrainResolverProvider"
        seed-nodes = [
            "pekko://"${clustering.cluster.name}"@"${clustering.seed-ip}":"${clustering.seed-port}
        ]

        failure-detector {
            acceptable-heartbeat-pause = 30 s
            threshold = 20.0
            expected-response-after = 10 s
        }

        sharding {
            passivation {
                strategy = "default-idle-strategy"
                default-idle-strategy {
                  idle-entity.timeout = 1200.hours
                }
            }

            least-shard-allocation-strategy {
                rebalance-threshold = 100000
            }

            verbose-debug-logging = off
            waiting-for-state-timeout = 1 minute
        }
    }

    cluster.bootstrap {
        contact-point-discovery {
            service-name  = "pekko-node"
            port-name     = "management"
            protocol      = "http"
        }
    }

    management {
        http {
            hostname = "0.0.0.0"
            port = ${clustering.management-http-port}
        }
    }

    discovery {
        method = config
    }
}

clustering {
    ip = "127.0.0.1"
    ip = ${?CLUSTER_IP}
    port = 1600
    port = ${?CLUSTER_PORT}
    seed-ip = "127.0.0.1"
    seed-ip = ${?CLUSTER_IP}
    seed-ip = ${?SEED_PORT_1600_TCP_ADDR}
    seed-port = 1600
    seed-port = ${?SEED_PORT_1600_TCP_PORT}
    management-http-port = 8558
    management-http-port = ${?MANAGEMENT_HTTP_PORT}
    cluster.name = hyperbolic-time-chamber
}

htc {
        simulation {
            config-file = ${?HTC_SIMULATION_CONFIG_FILE}
            snapshot-interval = 10000000
        }
        time-manager {
            total-instances = 1024
            total-instances = ${?HTC_TIME_MANAGER_INSTANCES}

            max-instances-per-node = 128
            max-instances-per-node = ${?HTC_TIME_MANAGER_PER_NODE}

            batch-size = 100000

            # Lookahead optimization: allow actors to advance multiple ticks
            # Set to 1 to disable (default conservative synchronous behavior)
            # Values > 1 enable speculative execution within safe windows
            lookahead-window = 1
            lookahead-window = ${?HTC_TIME_MANAGER_LOOKAHEAD}

            # Throughput metrics logging
            # Log ticks/second metrics every N ticks (0 to disable)
            metrics-log-interval = 500
            metrics-log-interval = ${?HTC_TIME_MANAGER_METRICS_INTERVAL}

            # Window-based execution (Strategy 2)
            # Process multiple ticks per synchronization barrier (1 to disable)
            # Values > 1 reduce barrier frequency (complements lookahead)
            window-size = 1
            window-size = ${?HTC_TIME_MANAGER_WINDOW_SIZE}

            verbose-logging = true
            verbose-logging = ${?HTC_TIME_MANAGER_VERBOSE_LOGGING}

            snapshot-interval = 10000000
            snapshot-interval = ${?HTC_TIME_MANAGER_SNAPSHOT_INTERVAL}

            actor-timeout-ms = 180000
            actor-timeout-ms = ${?HTC_TIME_MANAGER_ACTOR_TIMEOUT_MS}

            sync-timeout-ms = 30000
            sync-timeout-ms = ${?HTC_TIME_MANAGER_SYNC_TIMEOUT_MS}

            stale-event-max-age-ms = 30000
            stale-event-max-age-ms = ${?HTC_TIME_MANAGER_STALE_EVENT_MAX_AGE_MS}

            health-check-interval-seconds = 120
            health-check-interval-seconds = ${?HTC_TIME_MANAGER_HEALTH_CHECK_INTERVAL}
        }


    report-manager {
        default-strategy = "json"
        enabled-strategies = ["csv", "json"]

        csv {
            prefix = "htc_simulation_"
            directory = "/app/hyperbolic-time-chamber/output/reports/csv"
            number-of-instances = 2
            number-of-instances-per-node = 1
            batch-size = 1000
        }

        json {
            prefix = "htc_simulation_"
            directory = "/app/hyperbolic-time-chamber/output/reports/json"
            number-of-instances = 256
            number-of-instances = ${?HTC_REPORT_JSON_INSTANCES}
            number-of-instances-per-node = 256
            number-of-instances-per-node = ${?HTC_REPORT_JSON_PER_NODE}
            batch-size = 50000
        }
    }

    brokers {
        kafka {
            bootstrap-servers = "localhost:9092"

            consumer {
                group-id-suffix = "htc-group"
                auto-offset-reset = "earliest"
            }
        }
    }

    simulation {
        # random-seed = 12345
        # random-seed = ${?HTC_RANDOM_SEED}
    }
}