include "version"

pekko.library-extensions += "org.apache.pekko.stream.SystemMaterializer$"

pekko {
    home = ""
    loglevel = "DEBUG"
    stdout-loglevel = "DEBUG"
    loggers-dispatcher = "pekko.actor.default-dispatcher"
    loggers = ["org.apache.pekko.event.slf4j.Slf4jLogger"]
    logging-filter = "org.apache.pekko.event.slf4j.Slf4jLoggingFilter"
    logger-startup-timeout = 5s
    log-dead-letters = on
    log-dead-letters-during-shutdown = true
    log-dead-letters-suspend-duration = 5 minutes
    log-config-on-start = off
    daemonic = off
    jvm-exit-on-fatal-error = true
    jvm-shutdown-hooks = true
    fail-mixed-versions = false
    library-extensions = ${?pekko.library-extensions} ["org.apache.pekko.serialization.SerializationExtension$"]
    extensions = []

    stream {
        materializer {
            initial-input-buffer-size = 4
            max-input-buffer-size = 16
            dispatcher = "pekko.actor.default-dispatcher"
            mailbox {
                mailbox-type = "org.apache.pekko.dispatch.SingleConsumerOnlyUnboundedMailbox"
            }
            blocking-io-dispatcher = "pekko.actor.default-blocking-io-dispatcher"
            subscription-timeout {
                mode = cancel
                timeout = 60s
            }
            debug-logging = off
            output-burst-limit = 1000
            auto-fusing = on
            max-fixed-buffer-size = 1000000000
            sync-processing-limit = 1000
            debug {
                fuzzing-mode = off
            }
            io.tcp {
                write-buffer-size = 16 KiB
                coalesce-writes = 10
            }
            creation-timeout = 1 minute
            stream-ref {
                buffer-capacity = 32
                demand-redelivery-interval = 1 second
                subscription-timeout = 60 seconds
                final-termination-signal-deadline = 2 seconds
            }
        }
    }

    java-flight-recorder {
        enabled = true
    }

    event {
        logger = "org.apache.pekko.event.slf4j.Slf4jLogger"
    }

    actor {
        provider = cluster
        guardian-supervisor-strategy = "org.apache.pekko.actor.DefaultSupervisorStrategy"

        router {
            type-mapping {
                from-code = "org.apache.pekko.routing.NoRouter"
                round-robin-pool = "org.apache.pekko.routing.RoundRobinPool"
                round-robin-group = "org.apache.pekko.routing.RoundRobinGroup"
                random-pool = "org.apache.pekko.routing.RandomPool"
                random-group = "org.apache.pekko.routing.RandomGroup"
                balancing-pool = "org.apache.pekko.routing.BalancingPool"
                smallest-mailbox-pool = "org.apache.pekko.routing.SmallestMailboxPool"
                broadcast-pool = "org.apache.pekko.routing.BroadcastPool"
                broadcast-group = "org.apache.pekko.routing.BroadcastGroup"
                scatter-gather-pool = "org.apache.pekko.routing.ScatterGatherFirstCompletedPool"
                scatter-gather-group = "org.apache.pekko.routing.ScatterGatherFirstCompletedGroup"
                tail-chopping-pool = "org.apache.pekko.routing.TailChoppingPool"
                tail-chopping-group = "org.apache.pekko.routing.TailChoppingGroup"
                consistent-hashing-pool = "org.apache.pekko.routing.ConsistentHashingPool"
                consistent-hashing-group = "org.apache.pekko.routing.ConsistentHashingGroup"
            }
        }

        default-mailbox {
            mailbox-type = "org.apache.pekko.dispatch.UnboundedMailbox"
            mailbox-capacity = 1000
            mailbox-push-timeout-time = 10s
            stash-capacity = -1
        }

        mailbox {
            requirements {
                "org.apache.pekko.dispatch.UnboundedMessageQueueSemantics" = pekko.actor.mailbox.unbounded-queue-based
                "org.apache.pekko.dispatch.BoundedMessageQueueSemantics" = pekko.actor.mailbox.bounded-queue-based
                "org.apache.pekko.dispatch.DequeBasedMessageQueueSemantics" = pekko.actor.mailbox.unbounded-deque-based
                "org.apache.pekko.dispatch.UnboundedDequeBasedMessageQueueSemantics" = pekko.actor.mailbox.unbounded-deque-based
                "org.apache.pekko.dispatch.BoundedDequeBasedMessageQueueSemantics" = pekko.actor.mailbox.bounded-deque-based
                "org.apache.pekko.dispatch.MultipleConsumerSemantics" = pekko.actor.mailbox.unbounded-queue-based
                "org.apache.pekko.dispatch.ControlAwareMessageQueueSemantics" = pekko.actor.mailbox.unbounded-control-aware-queue-based
                "org.apache.pekko.dispatch.UnboundedControlAwareMessageQueueSemantics" = pekko.actor.mailbox.unbounded-control-aware-queue-based
                "org.apache.pekko.dispatch.BoundedControlAwareMessageQueueSemantics" = pekko.actor.mailbox.bounded-control-aware-queue-based
                "org.apache.pekko.event.LoggerMessageQueueSemantics" = pekko.actor.mailbox.logger-queue
            }

            unbounded-queue-based {
                mailbox-type = "org.apache.pekko.dispatch.UnboundedMailbox"
            }

            bounded-queue-based {
                mailbox-type = "org.apache.pekko.dispatch.BoundedMailbox"
            }

            unbounded-deque-based {
                mailbox-type = "org.apache.pekko.dispatch.UnboundedDequeBasedMailbox"
            }

            bounded-deque-based {
                mailbox-type = "org.apache.pekko.dispatch.BoundedDequeBasedMailbox"
            }

            unbounded-control-aware-queue-based {
                mailbox-type = "org.apache.pekko.dispatch.UnboundedControlAwareMailbox"
            }

            bounded-control-aware-queue-based {
                mailbox-type = "org.apache.pekko.dispatch.BoundedControlAwareMailbox"
            }

            logger-queue {
                mailbox-type = "org.apache.pekko.event.LoggerMailboxType"
            }
        }

        default-dispatcher {
            type = "Dispatcher"
            executor = "default-executor"
            default-executor {
                fallback = "fork-join-executor"
            }
            affinity-pool-executor {
                parallelism-min = 4
                parallelism-factor = 0.8
                parallelism-max = 64
                task-queue-size = 512
                rejection-handler = "org.apache.pekko.dispatch.affinity.ThrowOnOverflowRejectionHandler"
                idle-cpu-level = 5
                queue-selector = "org.apache.pekko.dispatch.affinity.FairDistributionHashCache"
                fair-work-distribution {
                    threshold = 128
                }
            }

            fork-join-executor {
                parallelism-min = 8
                parallelism-factor = 1.0
                parallelism-max = 64
                task-peeking-mode = "FIFO"
                maximum-pool-size = 32767
            }
            thread-pool-executor {
                keep-alive-time = 60s
                fixed-pool-size = off
                core-pool-size-min = 8
                core-pool-size-factor = 3.0
                core-pool-size-max = 64
                max-pool-size-min = 8
                max-pool-size-factor = 3.0
                max-pool-size-max = 64
                task-queue-size = -1
                task-queue-type = "linked"
                allow-core-timeout = on
            }
            virtual-thread-executor {
                fallback = "fork-join-executor"
            }
            shutdown-timeout = 1s
            throughput = 5
            throughput-deadline-time = 0ms
            attempt-teamwork = on
            mailbox-requirement = ""
        }

        internal-dispatcher {
            type = "Dispatcher"
            executor = "fork-join-executor"
            throughput = 5
            fork-join-executor {
                parallelism-min = 4
                parallelism-factor = 1.0
                parallelism-max = 64
            }
        }

        default-blocking-io-dispatcher {
            type = "Dispatcher"
            executor = "thread-pool-executor"
            throughput = 1

            thread-pool-executor {
                fixed-pool-size = 16
            }
        }

        debug {
            receive = on
            lifecycle = on
            autoreceive = false
            fsm = false
            event-stream = true
            unhandled = false
            router-misconfiguration = false
        }

        creation-timeout = 10s
        unstarted-push-timeout = 10s
        allow-java-serialization = off
        serialize-messages = on
        serialize-creators = on
        no-serialization-verification-needed-class-prefix = [
            "org.interscity.htc.core.util"
        ]

        deployment {
            default {
                virtual-nodes-factor = 10.0
            }

            /system/log1-Slf4jLogger {
                dispatcher = log-dispatcher
                router = "round-robin-pool"
                nr-of-instances = 5
                timeout = 1 minute
                resizer {
                    enabled = true
                    lower-bound = 2
                    upper-bound = 15
                    pressure-threshold = 1
                    rampup-rate = 0.2
                    backoff-threshold = 0.3
                    backoff-rate = 0.1
                    messages-per-resize = 10
                }
                mailbox = ""
                dispatcher = ""
                remote = ""
                target {
                    nodes = []
                }
                cluster {
                    enabled = off
                    max-nr-of-instances-per-node = 1
                    max-total-nr-of-instances = 10000
                    allow-local-routees = on
                    use-roles = []
                    use-role = ""
                }
                optimal-size-exploring-resizer {
                    enabled = off
                }
            }
        }
    }

    scheduler {
        implementation = "org.apache.pekko.actor.LightArrayRevolverScheduler"
        tick-duration = 100ms
        ticks-per-wheel = 512
        max-frame-time = 10s
        error-on-tick-duration-verification-failed = on
        shutdown-timeout = 5s
    }

    coordinated-shutdown {
        enable = true
        graceful-exit-actor-system = true
        default-phase-timeout = 5 s
        terminate-actor-system = on
        exit-jvm = off
        exit-code = 0
        run-by-jvm-shutdown-hook = on
        run-by-actor-system-terminate = on
        phases {
            before-service-unbind {
            }
            service-unbind {
                depends-on = [before-service-unbind]
            }
            service-requests-done {
                depends-on = [service-unbind]
            }
            service-stop {
                depends-on = [service-requests-done]
            }
            before-cluster-shutdown {
                depends-on = [service-stop]
            }
            cluster-sharding-shutdown-region {
                timeout = 10 s
                depends-on = [before-cluster-shutdown]
            }
            cluster-leave {
                depends-on = [cluster-sharding-shutdown-region]
            }
            cluster-exiting {
                timeout = 10 s
                depends-on = [cluster-leave]
            }
            cluster-exiting-done {
                depends-on = [cluster-exiting]
            }
            cluster-shutdown {
                depends-on = [cluster-exiting-done]
            }
            before-actor-system-terminate {
                depends-on = [cluster-shutdown]
            }
            actor-system-terminate {
                timeout = 10 s
                depends-on = [before-actor-system-terminate]
            }
        }
    }

    remote {
        accept-protocol-names = ["pekko", "akka"]
        protocol-name = "pekko"
        log-remote-lifecycle-events = off
        warn-about-direct-use = off
        artery {
            enabled = true
            transport = tcp
            canonical {
                hostname = ${clustering.ip}
                port = ${clustering.port}
            }
            large-message-destinations = []
            untrusted-mode = off
            trusted-selection-paths = []
            log-received-messages = off
            log-sent-messages = off
            log-frame-size-exceeding = off
            ssl {
                enabled = off
                ssl-engine-provider = org.apache.pekko.remote.artery.tcp.ConfigSSLEngineProvider
            }
            advanced {
                maximum-frame-size = 256 KiB
                buffer-pool-size = 128
                maximum-large-frame-size = 2 MiB
                large-buffer-pool-size = 32
                test-mode = off
                materializer = ${pekko.stream.materializer}
                use-dispatcher = "pekko.remote.default-remote-dispatcher"
                use-control-stream-dispatcher = "pekko.actor.internal-dispatcher"
                inbound-lanes = 4
                outbound-lanes = 1
                outbound-message-queue-size = 3072
                outbound-control-queue-size = 20000
                outbound-large-message-queue-size = 256
                system-message-buffer-size = 20000
                system-message-resend-interval = 1 second
                handshake-timeout = 60 seconds
                handshake-retry-interval = 1 second
                inject-handshake-interval = 1 second
                give-up-system-message-after = 6 hours
                stop-idle-outbound-after = 5 minutes
                quarantine-idle-outbound-after = 6 hours
                stop-quarantined-after-idle = 3 seconds
                remove-quarantined-association-after = 1 h
                shutdown-flush-timeout = 1 second
                death-watch-notification-flush-timeout = 3 seconds
                inbound-restart-timeout = 5 seconds
                inbound-max-restarts = 5
                outbound-restart-backoff = 1 second
                outbound-restart-timeout = 5 seconds
                outbound-max-restarts = 5
                compression {
                    actor-refs {
                        max = 256
                        advertisement-interval = 1 minute
                    }
                    manifests {
                        max = 256
                        advertisement-interval = 1 minute
                    }
                }
                instruments = ${?pekko.remote.artery.advanced.instruments} []
                aeron {
                    log-aeron-counters = false
                    embedded-media-driver = on
                    aeron-dir = ""
                    delete-aeron-dir = yes
                    idle-cpu-level = 5
                    give-up-message-after = 60 seconds
                    client-liveness-timeout = 26 seconds
                    publication-unblock-timeout = 40 seconds
                    image-liveness-timeout = 10 seconds
                    driver-timeout = 27 seconds
                }
                tcp {
                    connection-timeout = 5 seconds
                    outbound-client-hostname = ""
                }
            }
        }
        default-remote-dispatcher {
            type = Dispatcher
            executor = "fork-join-executor"
            fork-join-executor {
                parallelism-min = 2
                parallelism-factor = 0.5
                parallelism-max = 16
            }
            throughput = 10
        }
        deployment {
            enable-whitelist = off
            enable-allow-list = ${pekko.remote.deployment.enable-whitelist}
            whitelist = []
            allowed-actor-classes = ${pekko.remote.deployment.whitelist}
            default {
                router = round-robin-pool
                nr-of-instances = 5
            }
        }
        log-sent-messages = off
        log-received-messages = off
        use-unsafe-remote-features-outside-cluster = off
        warn-unsafe-watch-outside-cluster = on
        watch-failure-detector {
            implementation-class = "org.apache.pekko.remote.PhiAccrualFailureDetector"
            heartbeat-interval = 1 s
            threshold = 10.0
            max-sample-size = 200
            min-std-deviation = 100 ms
            acceptable-heartbeat-pause = 10 s
            unreachable-nodes-reaper-interval = 1s
            expected-response-after = 1 s
        }
        classic {
            use-dispatcher = "pekko.remote.default-remote-dispatcher"
            log-received-messages = off
            log-sent-messages = off
            log-frame-size-exceeding = off
            large-message-destinations = []
            untrusted-mode = off
            trusted-selection-paths = []
            log-remote-lifecycle-events = on
            startup-timeout = 35 s
            shutdown-timeout = 10 s
            flush-wait-on-shutdown = 2 s
            retry-gate-closed-for = 5 s
            prune-quarantine-marker-after = 5 d
            quarantine-after-silence = 2 d
            log-buffer-size-exceeding = 50000
            system-message-buffer-size = 20000
            system-message-ack-piggyback-timeout = 0.3 s
            resend-interval = 2 s
            resend-limit = 200
            initial-system-message-delivery-timeout = 3 m
            use-passive-connections = on
            backoff-interval = 5 ms
            command-ack-timeout = 30 s
            handshake-timeout = 15 s
            enabled-transports = ["pekko.remote.classic.netty.tcp"]
            adapters {
                gremlin = "org.apache.pekko.remote.transport.FailureInjectorProvider"
                trttl = "org.apache.pekko.remote.transport.ThrottlerProvider"
            }
            netty.tcp {
                transport-class = "org.apache.pekko.remote.transport.netty.NettyTransport"
                applied-adapters = []
                port = 7355
                hostname = ""
                bind-port = ""
                bind-hostname = ""
                enable-ssl = false
                connection-timeout = 15 s
                use-dispatcher-for-io = ""
                write-buffer-high-water-mark = 0b
                write-buffer-low-water-mark = 0b
                send-buffer-size = 256000b
                receive-buffer-size = 256000b
                maximum-frame-size = 128000b
                backlog = 4096
                tcp-nodelay = on
                tcp-keepalive = on
                tcp-reuse-addr = off-for-windows
                server-socket-worker-pool {
                    pool-size-min = 2
                    pool-size-factor = 1.0
                    pool-size-max = 2
                }
                client-socket-worker-pool {
                    pool-size-min = 2
                    pool-size-factor = 1.0
                    pool-size-max = 2
                }
            }
            netty.ssl = ${pekko.remote.classic.netty.tcp}
            netty.ssl = {
                enable-ssl = false
            }
        }
    }

    cluster {
        downing-provider-class = "org.apache.pekko.cluster.sbr.SplitBrainResolverProvider"
        seed-nodes = [
            "pekko://"${clustering.cluster.name}"@"${clustering.seed-ip}":"${clustering.seed-port}
        ]
        sharding {
            passivation {
                strategy = default-strategy
                default-strategy {
                    idle-entity.timeout = 5.minutes
                }
            }
        }
    }

    cluster.bootstrap {
        contact-point-discovery {
            service-name  = "pekko-node"
            port-name     = "management"
            protocol      = "http"
        }
    }

    management {
        http {
            hostname = "0.0.0.0"
            port = 8558
        }
    }

    discovery {
        method = config
    }
}

clustering {
    ip = "127.0.0.1"
    ip = ${?CLUSTER_IP}
    port = 1600
    port = ${?CLUSTER_PORT}
    seed-ip = "127.0.0.1"
    seed-ip = ${?CLUSTER_IP}
    seed-ip = ${?SEED_PORT_1600_TCP_ADDR}
    seed-port = 1600
    seed-port = ${?SEED_PORT_1600_TCP_PORT}
    cluster.name = hyperbolic-time-chamber
}

report-manager {
    enabled-strategies = ["csv", "json", "mongodb", "cassandra", "hbase", "hadoop"]

    hbase {
        zookeeper-quorum = "localhost:2181"
        table-name = "simulation_reports"
    }

    hadoop {
        namenode-uri = "hdfs://localhost:9000"
        directory = "/user/simulation_reports"
    }

    csv {
        directory = "/tmp/reports/csv"
    }

    json {
        directory = "/tmp/reports/json"
    }

    mongodb {
        uri = "mongodb://localhost:27017"
        database = "simulation_reports"
    }

    cassandra {
        contact-points = ["localhost:9042"]
        keyspace = "simulation_reports"
    }
}

databases {
    cassandra {
        default {
            contact-points = ["127.0.0.1:9042"]
            keyspace = "keyspace1"
            local-datacenter = "datacenter1"
            credentials {
                username = "your-username"
                password = "your-password"
            }
        }
    }
}

brokers {
    kafka {
        bootstrap-servers = "localhost:9092"

        consumer {
            group-id-suffix = "htc-group"
            auto-offset-reset = "earliest"
        }
    }
}